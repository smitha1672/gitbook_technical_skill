# C ++

```text
g++ -std=c++11 main.cpp
```
[thispointer.com](https://thispointer.com/c-interview-questions/)
<br>
[GeeksforGeeks](https://www.geeksforgeeks.org/c-plus-plus/)

## TODO

## [INHERITANCE](https://www.geeksforgeeks.org/inheritance-in-c/)

Modes of Inheritance

```text
1. Public mode
2. Protected mode
3. Private mode
```

Implementing inheritance Syntax

```text
class subclass_name : access_mode base_class_name
{
      //body of subclass
};
```

Types of Inheritance

```text
1. Single Inheritance
2. Multiple Inheritance
3. Multilevel Inheritance
4. Hierarchical Inheritance
5. Hybrid (Virtual) Inheritance
```

### [ACCESS MODIFIERS Public/Private/Protected](https://www.geeksforgeeks.org/access-modifiers-in-c/#:~:targetText=Protected%3A%20Protected%20access%20modifier%20is,derived%20class)%20of%20that%20class.)

To expalin Public/Private/Protected

## [OVERLOADING](HTTPS://WWW.GEEKSFORGEEKS.ORG/OPERATOR-OVERLOADING-C/)

FOLLOWING IS THE LIST OF OPERATORS THAT CANNOT BE OVERLOADED.

```TEXT
. (DOT)
::
?:
SIZEOF
```

### SIMPLE EXAMPLE

```TEXT
#INCLUDE<IOSTREAM>
USING NAMESPACE STD;

CLASS COMPLEX {
    PRIVATE:
        INT REAL, IMAG;
    PUBLIC:
        COMPLEX(INT R = 0, INT I =0) {REAL = R; IMAG = I;}

        // THIS IS AUTOMATICALLY CALLED WHEN '+' IS USED WITH
        // BETWEEN TWO COMPLEX OBJECTS
        COMPLEX OPERATOR + (COMPLEX CONST &OBJ) {
            COMPLEX RES;
            RES.REAL = REAL + OBJ.REAL;
            RES.IMAG = IMAG + OBJ.IMAG;
            RETURN RES;
        }
        VOID PRINT() { COUT << REAL
            << " + I" << IMAG << ENDL; }
};

INT MAIN()
{
    COMPLEX C1(10, 5), C2(2, 4);
    COMPLEX C3 = C1 + C2; // AN EXAMPLE CALL TO "OPERATOR+"
    C3.PRINT();
}
```

### [TYPES OF OPERATOR OVERLOADING](HTTPS://WWW.GEEKSFORGEEKS.ORG/TYPES-OF-OPERATOR-OVERLOADING-IN-C/)

OPERATOR OVERLOADING CAN BE DONE BY USING THREE APPROACHES, THEY ARE:

1. OVERLOADING UNARY OPERATOR.
2. OVERLOADING BINARY OPERATOR.
3. OVERLOADING BINARY OPERATOR USING A `FRIEND` FUNCTION.

+ ISSUE LEARNING

```TEXT
CLASS BOX {
PRIVATE:
    ...
PUBLIC:
    BOOL OPERATOR<(BOX&);                       //OVERLOADING BINARY OPERATOR
    FRIEND OSTREAM& OPERATOR<<(OSTREAM&, BOX&); // OVERLOADING BINARY OPERATOR USING A FRIEND FUNCTION
};

BOOL BOX::OPERATOR<(BOX& B)
{
    RETURN FALSE;
}

OSTREAM& BOX::OPERATOR<<(OSTREAM& OUT, BOX& BOX) // BUILDING FAILURE
OSTREAM& OPERATOR<<(OSTREAM& OUT, BOX& BOX) // BUILDING PASS
{
    RETURN OUT;
}
```


## [ITERATORS](HTTPS://WWW.GEEKSFORGEEKS.ORG/ITERATORS-C-STL/)

### VECTOR

```TEXT
VECTOR<INT> AR = { 1, 2, 3, 4, 5 };
// DECLARING ITERATOR TO A VECTOR
VECTOR<INT>::ITERATOR PTR;

// DISPLAYING VECTOR ELEMENTS USING BEGIN() AND END()
COUT << "THE VECTOR ELEMENTS ARE : ";
FOR (PTR = AR.BEGIN(); PTR < AR.END(); PTR++)
    COUT << *PTR << " ";
```

## [CONSTRUCTORS](HTTPS://WWW.GEEKSFORGEEKS.ORG/CONSTRUCTORS-C/#:~:TARGETTEXT=A%20CONSTRUCTOR%20IS%20A%20MEMBER,MEMBER%20FUNCTION%20OF%20THE%20CLASS.)

A CONSTRUCTOR IS A MEMBER FUNCTION OF A CLASS WHICH INITIALIZES OBJECTS OF A CLASS.
IN C++, CONSTRUCTOR IS AUTOMATICALLY CALLED WHEN OBJECT(INSTANCE OF CLASS) CREATE.
IT IS SPECIAL MEMBER FUNCTION OF THE CLASS.

```TEXT
1. CONSTRUCTOR HAS SAME NAME AS THE CLASS ITSELF
2. CONSTRUCTORS DON’T HAVE RETURN TYPE
3. A CONSTRUCTOR IS AUTOMATICALLY CALLED WHEN AN OBJECT IS CREATED.
4. IF WE DO NOT SPECIFY A CONSTRUCTOR, C++ COMPILER GENERATES A DEFAULT CONSTRUCTOR FOR US
(EXPECTS NO PARAMETERS AND HAS AN EMPTY BODY).
```

```TEXT
CLASS BOX {
PUBLIC:
    INT L, B, H;
PUBLIC:
    BOX();
    BOX(INT L, INT B, INT H);
};

/*
DEFAULT CONSTRUCTORS:
DEFAULT CONSTRUCTOR IS THE CONSTRUCTOR WHICH DOESN’T TAKE ANY ARGUMENT.
IT HAS NO PARAMETERS.
*/
BOX::BOX()
{
    L = B = H = 0;
}

/*
PARAMETERIZED CONSTRUCTORS:
IT IS POSSIBLE TO PASS ARGUMENTS TO CONSTRUCTORS.
TYPICALLY, THESE ARGUMENTS HELP INITIALIZE AN OBJECT WHEN IT IS CREATED.
TO CREATE A PARAMETERIZED CONSTRUCTOR, SIMPLY ADD PARAMETERS TO IT THE WAY YOU WOULD TO ANY OTHER
FUNCTION.
WHEN YOU DEFINE THE CONSTRUCTOR’S BODY, USE THE PARAMETERS TO INITIALIZE THE OBJECT.
*/
BOX::BOX(INT IL, INT IB, INT IH)
{
    L = IL;
    B = IB;
    H = IH;
}

INT MAIN(VOID)
{
    BOX BOX1(1, 2, 3);
    BOX BOX2;
    STD::COUT << BOX1.L << " "<< BOX2.L << "\N";
    RETURN 0;
}

OUTPUT: 1 0
```

## CLASS

THE DATA MEMBERS OF `A CLASS ARE PRIVATE BY DEFAULT` AND `THE MEMBERS OF A STRUCTURE ARE PUBLIC BY DEFAULT`.

IT ALSO HAS ACCESS SPECIFIERS, WHICH RESTRICT THE ACCESS OF MEMBER ELEMENTS.
THE PRIMARILY USED ONES ARE THE FOLLOWING:
PUBLIC: PUBLIC MEMBERS (VARIABLES, METHODS) CAN BE ACCESSED FROM ANYWHERE THE CODE IS VISIBLE.
PRIVATE: PRIVATE MEMBERS CAN BE ACCESSED ONLY BY OTHER MEMBER FUNCTIONS, AND IT CAN NOT BE ACCESSED OUTSIDE OF CLASS.

CLASS CAN BE REPRESENTED IN THE FORM OF

```TEXT
CLASS CLASSNAME {
ACCESS_SPECIFIER1:
    TYPE1 VAL1;
    TYPE2 VAL2;
    RET_TYPE1 METHOD1(TYPE_ARG1 ARG1, TYPE_ARG2 ARG2,...)
    ...
ACCESS_SPECIFIER2:
    TYPE3 VAL3;
    TYPE4 VAL4;
    RET_TYPE2 METHOD2(TYPE_ARG3 ARG3, TYPE_ARG4 ARG4,...)
    ...
};
```

IT'S A COMMON PRACTICE TO MAKE ALL VARIABLES PRIVATE, AND SET/GET THEM USING PUBLIC METHODS. FOR EXAMPLE:

```TEXT
CLASS SAMPLECLASS {
    PRIVATE:
        INT VAL;
    PUBLIC:
        VOID SET(INT A) {
            VAL = A;
        }
        INT GET() {
            RETURN VAL;
        }
};
```

## [VECTOR](HTTPS://WWW.GEEKSFORGEEKS.ORG/VECTOR-IN-CPP-STL/)

[REF.1](HTTP://LARRY850806.GITHUB.IO/2016/06/06/STL2/)

### [INITIALIZE A VECTOR WITH 5 DIFFERENT WAYS](HTTPS://WWW.GEEKSFORGEEKS.ORG/INITIALIZE-A-VECTOR-IN-CPP-DIFFERENT-WAYS/)

```TEXT
INT MAIN(VOID)
{
    INT N = 3;

    // CREATE A VECTOR OF SIZE N WITH
    // ALL VALUES AS 10.
    VECTOR<INT> VECT(N, 10);
    RETURN 0;
}

INT MAIN (VOID)
{
    VECTOR<INT> VECT {10, 20, 30};
    ...
    RETURN 0;
}

INT MAIN (VOID)
{
    INT ARR[] = { 10, 20, 30 };
    INT N = SIZEOF(ARR) / SIZEOF(ARR[0]);
    /*VECT = 10, 20, 30*/
    VECTOR<INT> VECT(ARR, ARR + N);
    ...
    RETURN 0;
}

INT MAIN (VOID)
{
    INT ARR[] = { 10, 20, 30 };
    INT N = SIZEOF(ARR) / SIZEOF(ARR[0]);
    /*VECT = 10, 20, 30*/
    VECTOR<INT> VECT(ARR, ARR + N);
    ...
    RETURN 0;
}

INT MAIN (VOID)
{
    // CREATE AN EMPTY VECTOR
    VECTOR<INT> VECT;

    VECT.PUSH_BACK(10);
    VECT.PUSH_BACK(20);
    VECT.PUSH_BACK(30);

    FOR (INT X : VECT)
        COUT << X << " ";

    RETURN 0;
}

```

### 2D VECTOR

```TEXT
# HTTPS://THISPOINTER.COM/CREATING-A-MATRIX-USING-2D-VECTOR-IN-C-VECTOR-OF-VECTORS/

# DECLARATION OF 2D VECTOR OR VECTOR OF VECTOR IN C++
STD::VECTOR <STD::VECTOR<INT> > VEC2D

# INITIALIZING VECTOR OF VECTOR – 2D VECTOR

STD::VECTOR <NUMBER OF ELEMENTS, VALUE OF EACH ELEMENT>
STD::VECTOR<INT> (4, 1)

# NOW TO CREATE A VECTOR OF 5 VECTORS IN WHICH EACH VECTOR IS INITIALIZED AS ABOVE, WE WILL USE FOLLOWING SYNTAX,
STD::VECTOR <STD::VECTOR > VEC2D(5, STD::VECTOR(4, 1));

OUTPUT

1 , 1 , 1 , 1 ,
1 , 1 , 1 , 1 ,
1 , 1 , 1 , 1 ,
1 , 1 , 1 , 1 ,
1 , 1 , 1 , 1 ,

# ADDING A NEW ROW IN 2D VECTOR
VEC2D.PUSH_BACK(STD::VECTOR<INT>(4, 11));
```

```TEXT
# HTTPS://WWW.GEEKSFORGEEKS.ORG/2D-VECTOR-IN-CPP-WITH-USER-DEFINED-SIZE/

// C++ CODE TO DEMONSTRATE 2D VECTOR
#INCLUDE <IOSTREAM>
#INCLUDE <VECTOR> // FOR 2D VECTOR
USING NAMESPACE STD;

INT MAIN()
{
    // INITIALIZING 2D VECTOR "VECT" WITH
    // VALUES
    VECTOR<VECTOR<INT> > VECT{ { 1, 2, 3 },
                               { 4, 5, 6 },
                               { 7, 8, 9 } };

    // DISPLAYING THE 2D VECTOR
    FOR (INT I = 0; I < VECT.SIZE(); I++) {
        FOR (INT J = 0; J < VECT[I].SIZE(); J++)
            COUT << VECT[I][J] << " ";
        COUT << ENDL;
    }

    RETURN 0;
}

OUTOUT :

1 2 3
4 5 6
7 8 9
```

### INSERT AND ERASE

```TEXT
INT ARR[] = {1, 2, 3, 4, 5};
VECTOR<INT> VEC(ARR, ARR+5);    //VEC = [1, 2, 3, 4, 5]
VEC.INSERT(VEC.BEGIN(), 0); //VEC = [0, 1, 2, 3, 4, 5]
VEC.INSERT(VEC.END(), 3, 100); //VEC = [0, 1, 2, 3, 4, 5, 100, 100, 100]
VEC.ERASE(VEC.BEGIN()); //VEC = [1, 2, 3, 4, 5, 100, 100, 100]
VEC.ERASE(VEC.END()-1); //VEC = [1, 2, 3, 4, 5, 100, 100]
VEC.ERASE(VEC.BEGIN(), VEC.BEGIN() + 5); //VEC = [100, 100];
COUT << VEC.SIZE() << ENDL; //SIZE = 2
```

## STRING

+ [C++ STRING CLASS AND ITS APPLICATIONS](HTTPS://WWW.GEEKSFORGEEKS.ORG/C-STRING-CLASS-AND-ITS-APPLICATIONS/)

```TEXT
C++ STRING CLASS HAS A LOT OF FUNCTIONS TO HANDLE STRING EASILY. MOST USEFUL OF THEM ARE DEMONSTRATED IN BELOW CODE.
// C++ PROGRAM TO DEMONSTRATE VARIOUS FUNCTION STRING CLASS
#INCLUDE <BITS/STDC++.H>
USING NAMESPACE STD;

INT
MAIN()
{
    // VARIOUS CONSTRUCTOR OF STRING CLASS
    // INITIALIZATION BY RAW STRING
    STRING STR1("FIRST STRING");
    // INITIALIZATION BY ANOTHER STRING
    STRING STR2(STR1);
    // INITIALIZATION BY CHARACTER WITH NUMBER OF OCCURENCE
    STRING STR3(5, '#');
    // INITIALIZATION BY PART OF ANOTHER STRING
    STRING STR4(STR1, 6, 6); // FROM 6TH INDEX (SECOND PARAMETER)
    // 6 CHARACTERS (THIRD PARAMETER)
    // INITIALIZATION BY PART OF ANOTHER STRING : ITEARTOR VERSION
    STRING STR5(STR2.BEGIN(), STR2.BEGIN() + 5);
    COUT << STR1 << ENDL;
    COUT << STR2 << ENDL;
    COUT << STR3 << ENDL;
    COUT << STR4 << ENDL;
    COUT << STR5 << ENDL;
    // ASSIGNMENT OPERATOR
    STRING STR6 = STR4;
    // CLEAR FUNCTION DELETES ALL CHARACTER FROM STRING
    STR4.CLEAR();
    // BOTH SIZE() AND LENGTH() RETURN LENGTH OF STRING AND
    // THEY WORK AS SYNONYMS
    INT LEN = STR6.LENGTH(); // SAME AS "LEN = STR6.SIZE();"
    COUT << "LENGTH OF STRING IS : " << LEN << ENDL;
    // A PARTICULAR CHARACTER CAN BE ACCESSED USING AT /
    // [] OPERATOR
    CHAR CH = STR6.AT(2); // SAME AS "CH = STR6[2];"
    COUT << "THIRD CHARACTER OF STRING IS : " << CH << ENDL;
    // FRONT RETURN FIRST CHARACTER AND BACK RETURNS LAST CHARCTER
    // OF STRING
    CHAR CH_F = STR6.FRONT(); // SAME AS "CH_F = STR6[0];"
    CHAR CH_B = STR6.BACK(); // SAME AS BELOW
    // "CH_B = STR6[STR6.LENGTH() - 1];"
    COUT << "FIRST CHAR IS : " << CH_F << ", LAST CHAR IS : "
        << CH_B << ENDL;
    // C_STR RETURNS NULL TERMINATED CHAR ARRAY VERSION OF STRING
    CONST CHAR* CHARSTR = STR6.C_STR();
    PRINTF("%S\N", CHARSTR);
    // APPEND ADD THE ARGUMENT STRING AT THE END
    STR6.APPEND(" EXTENSION");
    // SAME AS STR6 += " EXTENSION"
    // ANOTHER VERSION OF APPEND, WHICH APPENDS PART OF OTHER
    // STRING
    STR4.APPEND(STR6, 0, 6); // AT 0TH POSITION 6 CHARACTER
    COUT << STR6 << ENDL;
    COUT << STR4 << ENDL;
    // FIND RETURNS INDEX WHERE PATTERN IS FOUND.
    // IF PATTERN IS NOT THERE IT RETURNS PREDEFINED
    // CONSTANT NPOS WHOSE VALUE IS -1
    IF (STR6.FIND(STR4) != STRING::NPOS)
        COUT << "STR4 FOUND IN STR6 AT " << STR6.FIND(STR4)
            << " POS" << ENDL;
    ELSE
        COUT << "STR4 NOT FOUND IN STR6" << ENDL;
    // SUBSTR(A, B) FUNCTION RETURNS A SUBSTRING OF B LENGTH
    // STARTING FROM INDEX A
    COUT << STR6.SUBSTR(7, 3) << ENDL;
    // IF SECOND ARGUMENT IS NOT PASSED, STRING TILL END IS
    // TAKEN AS SUBSTRING
    COUT << STR6.SUBSTR(7) << ENDL;
    // ERASE(A, B) DELETES B CHARACTERS AT INDEX A
    STR6.ERASE(7, 4);
    COUT << STR6 << ENDL;
    // ITERATOR VERSION OF ERASE
    STR6.ERASE(STR6.BEGIN() + 5, STR6.END() - 3);
    COUT << STR6 << ENDL;
    STR6 = "THIS IS A EXAMPLES";
    // REPLACE(A, B, STR) REPLACES B CHARACTERS FROM A INDEX BY STR
    STR6.REPLACE(2, 7, "ESE ARE TEST");
    COUT << STR6 << ENDL;
    RETURN 0;
}
```

```TEXT
OUTPUT:
FIRST STRING
FIRST STRING
#####
STRING
FIRST
LENGTH OF STRING IS : 6
THIRD CHARACTER OF STRING IS : R
FIRST CHAR IS : S, LAST CHAR IS : G
STRING
STRING EXTENSION
STRING
STR4 FOUND IN STR6 AT 0 POS
EXT
EXTENSION
STRING NSION
STRINION
THESE ARE TEST EXAMPLES
```

```TEXT
ON BASIS OF ABOVE STRING FUNCTION SOME APPLICATION ARE WRITTEN BELOW :
// C++ PROGRAM TO DEMONSTRATE USES OF SOME STRING FUNCTION
#INCLUDE <BITS/STDC++.H>
USING NAMESPACE STD;

// THIS FUNCTION RETURNS FLOATING POINT PART OF A NUMBER-STRING
STRING
RETURNFLOATINGPART(STRING STR)
{
    INT POS = STR.FIND(".");
    IF (POS == STRING::NPOS)
        RETURN "";
    ELSE
        RETURN STR.SUBSTR(POS + 1);
}

// THIS FUNCTION CHECKS WHETHER STRING CONTAINS ALL DIGIT OR NOT
BOOL
CONTAINSONLYDIGIT(STRING STR)
{
    INT L = STR.LENGTH();
    FOR (INT I = 0; I < L; I++) {
        IF (STR.AT(I) < '0' || STR.AT(I) > '9')
            RETURN FALSE;
    }
    // IF WE REACH HERE ALL CHARACTER ARE DIGITS
    RETURN TRUE;
}

// THIS FUNCTION REPLACES ALL SINGLE SPACE BY %20
// USED IN URLS
STRING
REPLACEBLANKWITH20(STRING STR)
{
    STRING REPLACEBY = "%20";
    INT N = 0;
    // LOOP TILL ALL SPACE ARE REPLACED
    WHILE ((N = STR.FIND(" ", N)) != STRING::NPOS ) {
        STR.REPLACE(N, 1, REPLACEBY);
        N += REPLACEBY.LENGTH();
    }
    RETURN STR;
}

// DRIVER FUNCTION TO CHECK ABOVE METHODS
INT
MAIN()
{
    STRING FNUM = "23.342";
    COUT << "FLOATING PART IS : " << RETURNFLOATINGPART(FNUM)
        << ENDL;
    STRING NUM = "3452";
    IF (CONTAINSONLYDIGIT(NUM))
        COUT << "STRING CONTAINS ONLY DIGIT" << ENDL;
    STRING URLEX = "GOOGLE COM IN";
    COUT << REPLACEBLANKWITH20(URLEX) << ENDL;
    RETURN 0;
}
```

```TEXT
OUTPUT
FLOATING PART IS : 342
STRING CONTAINS ONLY DIGIT
GOOGLE%20COM%20IN
```

+ COPY STD::STRING INTO STD::VECTOR<CHAR>

```TEXT
STD::VECTOR HAS A CONSTRUCTOR THAT TAKES TWO ITERATORS. YOU CAN USE THAT:

STD::STRING STR = "HELLO";
STD::VECTOR<CHAR> DATA(STR.BEGIN(), STR.END());
IF YOU ALREADY HAVE A VECTOR AND WANT TO ADD THE CHARACTERS AT THE END, YOU NEED A BACK INSERTER:

STD::STRING STR = "HELLO";
STD::VECTOR<CHAR> DATA = /* ... */;
STD::COPY(STR.BEGIN(), STR.END(), STD::BACK_INSERTER(DATA));
```

+ PRINT STRING WITH PRINTF AND VECTOR

```TEXT
STD::VECTOR<CHAR> VEC;
VEC.PUSH_BACK('T');
VEC.PUSH_BACK('E');
VEC.PUSH_BACK('S');
VEC.PUSH_BACK('T');
VEC.PUSH_BACK('\0');
STD::OSTRINGSTREAM VTS;
IF (!VEC.EMPTY()) {
    STD::COPY(VEC.BEGIN(), VEC.END(), STD::OSTREAM_ITERATOR<CHAR>(VTS));
    // NOW ADD THE LAST ELEMENT WITH NO
    // DELIMITER
    VTS << VEC.BACK();
}
STD::STRING S = VTS.STR();
PRINTF("%S\N", S.C_STR());
```

+ PRINTF WITH STD::STRING?

```C
#INCLUDE <IOSTREAM>
#INCLUDE <STRING>
#INCLUDE <STDIO.H>

INT MAIN()
{
    USING NAMESPACE STD;

    STRING MYSTRING = "PRESS ENTER TO QUIT PROGRAM!";
    COUT << "COME UP AND C++ ME SOME TIME." << ENDL;
    PRINTF("FOLLOW THIS COMMAND: %S", MYSTRING.C_STR()); //NOTE THE USE OF C_STR
    CIN.GET();

    RETURN 0;
}
```

+ STRING::COPY

```C
// STRING::COPY
#INCLUDE <IOSTREAM>
#INCLUDE <STRING>

INT MAIN ()
{
    CHAR BUFFER[20];
    STD::STRING STR ("TEST STRING...");
    STD::SIZE_T LENGTH = STR.COPY(BUFFER,6,5);
    BUFFER[LENGTH]='\0';
    STD::COUT << "BUFFER CONTAINS: " << BUFFER << '\N';
    RETURN 0;
}
```

## STRINGSTREAM

```TEXT
CLEAR() — TO CLEAR THE STREAM
STR() — TO GET AND SET STRING OBJECT WHOSE CONTENT IS PRESENT IN STREAM.
OPERATOR << — ADD A STRING TO THE STRINGSTREAM OBJECT.
OPERATOR >> — READ SOMETHING FROM THE STRINGSTREAM OBJECT,
```

### EXAMPLE

+ [TO COUNT FREQUENCIES OF WORDS](HTTPS://WWW.GEEKSFORGEEKS.ORG/STRINGSTREAM-C-APPLICATIONS/)

```TEXT
#INCLUDE <BITS/STDC++.H>

USING NAMESPACE STD;

VOID PRINTFREQUENCY(STRING ST)
{
    // EACH WORD IT MAPPED TO IT'S FREQUENCY
    MAP<STRING, INT> FW;
    STRINGSTREAM SS(ST); // USED FOR BREAKING WORDS
    STRING WORD; // TO STORE INDIVIDUAL WORDS

    WHILE (SS >> WORD)
        FW[WORD]++;

    MAP<STRING, INT>::ITERATOR M;
    FOR (M = FW.BEGIN(); M != FW.END(); M++)
        COUT << M->FIRST << " -> "
            << M->SECOND << "\N";
}

INT MAIN(VOID)
{
    STRING S = "GEEKS FOR GEEKS IDE"
    PRINTFREQUENCY(S);
    RETURN 0;
}
```

## [RANGE-BASED](HTTPS://WWW.GEEKSFORGEEKS.ORG/RANGE-BASED-LOOP-C/)

```TEXT
FOR ( RANGE_DECLARATION : RANGE_EXPRESSION )
    LOOP_STATEMENT

PARAMETERS :
RANGE_DECLARATION :
A DECLARATION OF A NAMED VARIABLE, WHOSE TYPE IS THE
TYPE OF THE ELEMENT OF THE SEQUENCE REPRESENTED BY
RANGE_EXPRESSION, OR A REFERENCE TO THAT TYPE.
OFTEN USES THE AUTO SPECIFIER FOR AUTOMATIC TYPE
DEDUCTION.

RANGE_EXPRESSION :
ANY EXPRESSION THAT REPRESENTS A SUITABLE SEQUENCE
OR A BRACED-INIT-LIST.

LOOP_STATEMENT :
ANY STATEMENT, TYPICALLY A COMPOUND STATEMENT, WHICH
IS THE BODY OF THE LOOP.
```

```TEXT
// ILLUSTRATION OF RANGE-FOR LOOP
// USING CPP CODE
#INCLUDE <IOSTREAM>
#INCLUDE <VECTOR>
#INCLUDE <MAP>

//DRIVER
INT
MAIN()
{
    // ITERATING OVER WHOLE ARRAY
    STD::VECTOR<INT> V = {0, 1, 2, 3, 4, 5};
    FOR (AUTO I : V)
        STD::COUT << I << ' ';
    STD::COUT << '\N';
    // THE INITIALIZER MAY BE A BRACED-INIT-LIST
    FOR (INT N : {0, 1, 2, 3, 4, 5})
        STD::COUT << N << ' ';
    STD::COUT << '\N';
    // ITERATING OVER ARRAY
    INT A[] = {0, 1, 2, 3, 4, 5};
    FOR (INT N : A)
        STD::COUT << N << ' ';
    STD::COUT << '\N';
    // JUST RUNNING A LOOP FOR EVERY ARRAY
    // ELEMENT
    FOR (INT N : A)
        STD::COUT << "IN LOOP" << ' ';
    STD::COUT << '\N';
    // PRINTING STRING CHARACTERS
    STD::STRING STR = "GEEKS";
    FOR (CHAR C : STR)
        STD::COUT << C << ' ';
    STD::COUT << '\N';
    // PRINTING KEYS AND VALUES OF A MAP
    STD::MAP <INT, INT> MAP({{1, 1}, {2, 2}, {3, 3}});
    FOR (AUTO I : MAP)
        STD::COUT << '{' << I.FIRST << ", " << I.SECOND << "}\N";
}
```

```TEXT
OUTPUT:
0 1 2 3 4 5
0 1 2 3 4 5
0 1 2 3 4 5
IN LOOP IN LOOP IN LOOP IN LOOP IN LOOP IN LOOP
G E E K S
{1, 1}
{2, 2}
{3, 3}
```

## [MAP](HTTPS://WWW.GEEKSFORGEEKS.ORG/MAP-ASSOCIATIVE-CONTAINERS-THE-C-STANDARD-TEMPLATE-LIBRARY-STL/)
### UPPER BOUND

```TEXT
RETURNS AN ITERATOR TO THE FIRST ELEMENT GREATER THAN THE GIVEN KEY
SYNTAX:
    MAP_NAME.UPPER_BOUND(KEY)
```

```TEXT
#INCLUDE <MAP>

INT MAIN()
{
    USING NAMESPACE STD;
    // INITIALIZE CONTAINER
    MAP<INT, INT> MP;

    // INSERT ELEMENTS IN RANDOM ORDER
    MP.INSERT({ 12, 30 });
    MP.INSERT({ 11, 10 });
    MP.INSERT({ 15, 50 });
    MP.INSERT({ 14, 40 });

    // WHEN 11 IS PRESENT
    AUTO IT = MP.UPPER_BOUND(11);
    COUT << "THE UPPER BOUND OF KEY 11 IS ";
    COUT << (*IT).FIRST << " " << (*IT).SECOND << ENDL;

    // WHEN 13 IS NOT PRESENT
    IT = MP.UPPER_BOUND(13);
    COUT << "THE UPPER BOUND OF KEY 13 IS ";
    COUT << (*IT).FIRST << " " << (*IT).SECOND << ENDL;

    // WHEN 17 IS EXCEEDS THE MAXIMUM KEY, SO SIZE
    // OF MP IS RETURNED AS KEY AND VALUE AS 0.
    IT = MP.UPPER_BOUND(17);
    COUT << "THE UPPER BOUND OF KEY 17 IS ";
    COUT << (*IT).FIRST << " " << (*IT).SECOND;
    RETURN 0;
}

AFTER MAP:
11 10
12 30 < KEY:11 UPPER BOUND
14 40 < KEY:13 UPPER BOUND
15 50
-- -- < KEY:17 UPPER BOUND

OUTPUT:
THE UPPER BOUND OF KEY 11 IS 12 30
THE UPPER BOUND OF KEY 13 IS 14 40
THE UPPER BOUND OF KEY 17 IS 4 0
```

### LOWER BOUND

```TEXT
RETURNS AN ITERATOR POINTING TO THE FIRST ELEMENT THAT IS NOT LESS THAN
 (I.E. GREATER OR EQUAL TO) KEY.
SYNTAX:
    MAP_NAME.LOWER_BOUND(KEY)
```

```TEXT
// C++ FUNCTION FOR ILLUSTRATION
// MAP::LOWER_BOUND() FUNCTION
#INCLUDE <MAP>

INT MAIN()
{
    USING NAMESPACE STD;

    // INITIALIZE CONTAINER
    MAP<INT, INT> MP;

    // INSERT ELEMENTS IN RANDOM ORDER
    MP.INSERT({ 2, 30 });
    MP.INSERT({ 1, 10 });
    MP.INSERT({ 5, 50 });
    MP.INSERT({ 4, 40 });
    FOR (AUTO IT = MP.BEGIN(); IT != MP.END(); IT++) {
        COUT << (*IT).FIRST << " " << (*IT).SECOND << ENDL;
    }

    // WHEN 2 IS PRESENT
    AUTO IT = MP.LOWER_BOUND(2);
    COUT << "THE LOWER BOUND OF KEY 2 IS ";
    COUT << (*IT).FIRST << " " << (*IT).SECOND << ENDL;

    // WHEN 3 IS NOT PRESENT
    // POINTS TO NEXT GREATER AFTER 3
    IT = MP.LOWER_BOUND(3);
    COUT << "THE LOWER BOUND OF KEY 3 IS ";
    COUT << (*IT).FIRST << " " << (*IT).SECOND;

    // WHEN 6 EXCEEDS
    IT = MP.LOWER_BOUND(6);
    COUT << "\NTHE LOWER BOUND OF KEY 6 IS ";
    COUT << (*IT).FIRST << " " << (*IT).SECOND;
    RETURN 0;
}

OUTPUT:
1 10
2 30 < KEY:2 LOWER BOUND
4 40 < KEY:3 LOWER BOUND
5 50
- -- < KEY:6 LOWER BOUND
THE LOWER BOUND OF KEY 2 IS 2 30
THE LOWER BOUND OF KEY 3 IS 4 40
THE LOWER BOUND OF KEY 6 IS 4 0
```

### [MAP VS UNORDERED_MAP](HTTPS://WWW.GEEKSFORGEEKS.ORG/MAP-VS-UNORDERED_MAP-C/)

| TITLE | MAP | UNORDERED_MAP |
| ----- | --- | ------------  |
|ORDERING|INCREASING ORDER(BY DEFAULT)|NO ORDERING|
|IMPLEMENTATION|SELF BALANCING BST(LIKE RED-BLACK TREE)|HASH TABLE|
|SEARCH TIME|LOG(N)|O(1) AVERAGE/O(N) WORST CASE|
|INSERTION TIME|LOG(N) + REBALANCE|SAME AS SEARCH|
|DELETION TIME|LOG(N) + REBALANCE|SAME AS SEARCH|

+ USE STD::MAP WHEN

<IMG SRC="HTTPS://1.BP.BLOGSPOT.COM/-IRJ_G2XR7E8/VMU8MLBPOVI/AAAAAAAA_K4/SIDTGAMLUXE/S1600/27.4.PNG"
WIDTH="70%"
HEIGHT="70%"
ALT="MAP KEY AND VALUE"
ALIGN=CENTER />

<IMG SRC="HTTPS://3.BP.BLOGSPOT.COM/-P2D7QL_IUFE/VMU7PE7ZQRI/AAAAAAAA_KS/WC3G3ADRKBE/S1600/27.7.PNG"
WIDTH="70%"
HEIGHT="70%"
ALT="MAP ITERATOR"
ALIGN=CENTER />

```TEXT
# YOU NEED ORDERED DATA.
# YOU WOULD HAVE TO PRINT/ACCESS THE DATA (IN SORTED ORDER).
# YOU NEED PREDECESSOR/SUCCESSOR OF ELEMENTS.
# SEE ADVANTAGES OF BST OVER HASH TABLE FOR MORE CASES.
```

```TEXT
#INCLUDE <MAP>
INT MAIN()
{
    // ORDERED MAP
    STD::MAP<INT, INT> ORDER;

    // MAPPING VALUES TO KEYS
    ORDER[5] = 10;
    ORDER[3] = 5;
    ORDER[20] = 100;
    ORDER[1] = 1;

    // ITERATING THE MAP AND PRINTING ORDERED VALUES
    FOR (AUTO I = ORDER.BEGIN(); I != ORDER.END(); I++) {
        STD::COUT << I->FIRST << " : " << I->SECOND << '\N';
    }
}

OUTPUT:
1 : 1
3 : 5
5 : 10
20 : 100
```

+ USE STD::UNORDERED_MAP WHEN

```TEXT
# YOU NEED TO KEEP COUNT OF SOME DATA (EXAMPLE – STRINGS) AND NO ORDERING IS REQUIRED.
# YOU NEED SINGLE ELEMENT ACCESS I.E. NO TRAVERSAL.
```

```TEXT
#INCLUDE <UNORDERED_MAP>
INT MAIN()
{
    // UNORDERED MAP
    STD::UNORDERED_MAP<INT, INT> ORDER;

    // MAPPING VALUES TO KEYS
    ORDER[5] = 10;
    ORDER[3] = 5;
    ORDER[20] = 100;
    ORDER[1] = 1;

    // ITERATING THE MAP AND PRINTING UNORDERED VALUES
    FOR (AUTO I = ORDER.BEGIN(); I != ORDER.END(); I++) {
        STD::COUT << I->FIRST << " : " << I->SECOND << '\N';
    }
}

OUTPUT :
1 : 1
3 : 5
20 : 100
5 : 10
```
## ALGORITHMS
### [ARRAY SUM](HTTPS://WWW.GEEKSFORGEEKS.ORG/ARRAY-SUM-IN-CPP-STL/)

```TEXT
IN C++, WE CAN QUICKLY FIND ARRAY SUM USING ACCUMULATE()

#INCLUDE <VECTOR>
#INCLUDE <NUMERIC>
#INCLUDE <IOSTREAM>

USING NAMESPACE STD;

// USER DEFINED FUNCTION THAT RETURNS SUM OF
// ARR[] USING ACCUMULATE() LIBRARY FUNCTION.
INT
ARRAYSUM(INT A[], INT N)
{
    INT INITIAL_SUM = 0;
    RETURN ACCUMULATE(A, A+N, INITIAL_SUM);
}

INT
MAIN()
{
    INT A[] = {5, 10, 15} ;
    INT N = SIZEOF(A)/SIZEOF(A[0]);
    COUT << ARRAYSUM(A, N) << ENDL; // OUTPUT: 30
    RETURN 0;
}

//OR

// USER DEFINED FUNCTION THAT RETURNS SUM OF
// ARR[] USING ACCUMULATE() LIBRARY FUNCTION.
INT
ARRAYSUM(VECTOR<INT>& V)
{
    INT INITIAL_SUM = 0;
    RETURN ACCUMULATE(V.BEGIN(), V.END(), INITIAL_SUM);
}

INT
MAIN()
{
    VECTOR<INT> V;
    V.PUSH_BACK(5);
    V.PUSH_BACK(10);
    V.PUSH_BACK(15);
    COUT << ARRAYSUM(V) << ENDL;
    RETURN 0;
}
```

### [VECTOR: TO FIND THE MAXIMUM ELEMENT](HTTPS://WWW.GEEKSFORGEEKS.ORG/HOW-TO-FIND-THE-MAXIMUM-ELEMENT-OF-A-VECTOR-USING-STL-IN-C/)

```TEXT
#INCLUDE <VECTOR>
#INCLUDE <ALGORITHM>
#INCLUDE <IOSTREAM>

INT
EXAMPLE_1(VOID)
{
    USING NAMESPACE STD;
    // GET THE VECTOR
    INT ARR[] = { 1, 45, 54, 71, 76, 12 };
    VECTOR<INT> A(ARR, ARR+(SIZEOF(ARR)/SIZEOF(ARR[0])));
    // PRINT THE VECTOR
    COUT << "EXAMPLE1 VECTOR: ";
    FOR (INT I = 0; I < A.SIZE(); I++)
        COUT << A[I] << " ";
    COUT << ENDL;
    // FIND THE MAX ELEMENT
    COUT << "\NMAX ELEMENT = "
        << *MAX_ELEMENT(A.BEGIN(), A.END()) << ENDL; // OUTPUT: 76
    RETURN 0;
}

INT
EXAMPLE_2(VOID)
{
    // GET THE VECTOR
    INT ARR[] = { 1, 45, 54, 71, 76, 12 };
    STD::VECTOR<INT> A(ARR, ARR+(SIZEOF(ARR)/SIZEOF(ARR[0])));
    // PRINT THE VECTOR
    STD::COUT << "EAMPLE2 VECTOR: ";
    FOR (INT I = 0; I < A.SIZE(); I++)
        STD::COUT << A[I] << " ";
    STD::COUT << STD::ENDL;
    // FIND THE MAX ELEMENT
    STD::COUT << "\NMAX ELEMENT = "
        << *STD::MAX_ELEMENT(A.BEGIN(), A.END()) << STD::ENDL; // OUTPUT: 76
    RETURN 0;
}

INT
EXAMPLE_3(VOID)
{
    USING NAMESPACE STD;
    INT V[] = { 'A', 'C', 'K', 'D', 'E', 'F', 'H' };
    // FINDING THE MAXIMUM VALUE BETWEEN THE FIRST AND THE
    // FOURTH ELEMENT
    INT* I1;
    I1 = STD::MAX_ELEMENT(V, V + 4);
    COUT << CHAR(*I1) << "\N"; // OUTPUT: K
    RETURN 0;
}
```

### [ALGORITHMS LIBRARY](HTTPS://WWW.GEEKSFORGEEKS.ORG/ALGORITHMS-LIBRARY-C-STL/)

+ [STD::REVERSE() IN C++](HTTPS://WWW.GEEKSFORGEEKS.ORG/STDREVERSE-IN-C/)

```TEXT
// CPP PROGRAM TO ILLUSTRATE
// STD::REVERSE() FUNCTION OF STL
#INCLUDE<IOSTREAM>
#INCLUDE<ALGORITHM>
#INCLUDE<VECTOR>
USING NAMESPACE STD;
INT MAIN()
{
    VECTOR <INT> V ;
    // INSERTING ELEMENTS IN VECTOR
    FOR (INT I = 0; I < 8; I++)
        V.PUSH_BACK(I+10);
    COUT << "REVERSE ONLY FROM INDEX 5 TO 7 IN ARRAY:\N";
    // REVERSING ELEMENTS FROM INDEX 5 TO INDEX 7
    REVERSE(V.BEGIN() + 5, V.BEGIN() + 8);
    // DISPLAYING ELEMENTS OF VECTOR
    VECTOR <INT> :: ITERATOR IT;
    FOR (IT = V.BEGIN(); IT != V.END(); IT++)
        COUT << (*IT) << " ";
    // REVERSING DIRECTLY FROM BEGINNING TO END
    COUT << "\NREVERSE FULL ARRAY:\N";
    INT A[] = {4, 5, 6, 7};
    STD::REVERSE(STD::BEGIN(A), STD::END(A));
    // PRINT THE ARRAY
    STD::COUT << A[0] << A[1] << A[2] << A[3] << '\N';
    RETURN 0;
}
```

## [STD::`BACK_INSERTER`](HTTPS://WWW.GEEKSFORGEEKS.ORG/STDBACK_INSERTER-IN-CPP/)

`STD::BACK_INSERTER` CONSTRUCTS A BACK-INSERT ITERATOR THAT INSERTS NEW ELEMENTS AT THE END OF THE CONTAINER TO WHICH IT IS APPLIED. IT IS DEFINED INSIDE THE HEADER FILE.

+ EXAMPLE 1

```TEXT
// C++ PROGRAM TO DEMONSTRATE STD::BACK_INSERTER
#INCLUDE <IOSTREAM>
#INCLUDE <ITERATOR>
#INCLUDE <VECTOR>
#INCLUDE <ALGORITHM>
USING NAMESPACE STD;
INT MAIN()
{
    // DECLARING FIRST CONTAINER
    VECTOR<INT> V1 = { 1, 2, 3 };

    // DECLARING SECOND CONTAINER FOR
    // COPYING VALUES
    VECTOR<INT> V2 = { 4, 5, 6 };

    // USING STD::BACK_INSERTER INSIDE STD::COPY
    STD::COPY(V1.BEGIN(), V1.END(), STD::BACK_INSERTER(V2));
    // V2 NOW CONTAINS 4 5 6 1 2 3

    // DISPLAYING V1 AND V2
    COUT << "V1 = ";

    INT I;
    FOR (I = 0; I < 3; ++I) {
        COUT << V1[I] << " ";
    }

    COUT << "\NV2 = ";
    FOR (I = 0; I < 6; ++I) {
        COUT << V2[I] << " ";
    }

    RETURN 0;
}

OUTPUT:

V1 = 1 2 3
V2 = 4 5 6 1 2 3
```

+ EXAMPLE 2

NO PRIOR KNOWLEDGE OF SIZE OF CONTAINER REQUIRED : ONE OF THE SCENARIO WHERE SUCH A FUNCTION CAN BE EXTREMELY HELPFUL IS WHEN WE DON’T KNOW THE SIZE OF THE CONTAINER,
I.E., HOW MANY ELEMENTS WILL BE INSERTED INTO IT, SO ONE WAY IS TO MAKE THAT CONTAINER OF EXTREMELY LARGE SIZE,
BUT THE MOST EFFICIENT WAY WILL BE TO USE `STD::BACK_INSERTER()` IN SUCH A CASE, WITHOUT DECLARING THE SIZE OF THE CONTAINER.

```TEXT
// C++ PROGRAM TO DEMONSTRATE STD::BACK_INSERTER
#INCLUDE <IOSTREAM>
#INCLUDE <ITERATOR>
#INCLUDE <VECTOR>
#INCLUDE <ALGORITHM>
USING NAMESPACE STD;
INT MAIN()
{
    // DECLARING FIRST CONTAINER
    VECTOR<INT> V1 = { 1, 2, 3 };

    // DECLARING SECOND CONTAINER WITHOUT SPECIFYING
    // ITS SIZE
    VECTOR<INT> V2;

    // USING STD::BACK_INSERTER INSIDE STD::COPY
    STD::COPY(V1.BEGIN(), V1.END(), STD::BACK_INSERTER(V2));
    // V2 NOW CONTAINS 1 2 3

    // DISPLAYING V1 AND V2
    COUT << "V1 = ";

    INT I;
    FOR (I = 0; I < 3; ++I) {
        COUT << V1[I] << " ";
    }

    COUT << "\NV2 = ";
    FOR (I = 0; I < 3; ++I) {
        COUT << V2[I] << " ";
    }

    RETURN 0;
}

OUTPUT:

V1 = 1 2 3
V2 = 1 2 3
```


## [STD::`FRONT_INSERTER`](HTTPS://WWW.GEEKSFORGEEKS.ORG/STDFRONT_INSERTER-IN-CPP/)

`STD::FRONT_INSERTER` CONSTRUCTS A FRONT-INSERT ITERATOR THAT INSERTS NEW ELEMENTS AT THE FRONT OF THE
CONTAINER TO WHICH IT IS APPLIED. IT IS DEFINED INSIDE THE HEADER FILE .

+ WITH DEQUEUE

```TEXT
#NCLUDE <IOSTREAM>
#INCLUDE <ITERATOR>
#INCLUDE <DEQUE>
#INCLUDE <ALGORITHM>
USING NAMESPACE STD;
INT MAIN()
{
    // DECLARING FIRST CONTAINER
    DEQUE<INT> V1 = { 1, 2, 3 };

    // DECLARING SECOND CONTAINER FOR
    // COPYING VALUES
    DEQUE<INT> V2 = { 4, 5, 6 };

    // USING STD::FRONT_INSERTER INSIDE STD::COPY
    STD::COPY(V1.BEGIN(), V1.END(), STD::FRONT_INSERTER(V2));
    // V2 NOW CONTAINS 3 2 1 4 5 6

    // DISPLAYING V1 AND V2
    COUT << "V1 = ";

    INT I;
    FOR (I = 0; I < 3; ++I) {
        COUT << V1[I] << " ";
    }

    COUT << "\NV2 = ";
    FOR (I = 0; I < 6; ++I) {
        COUT << V2[I] << " ";
    }

    RETURN 0;
}

OUTPUT:
V1 = 1 2 3
V2 = 3 2 1 4 5 6
```

+ `REVERSING A CONTAINER`

NOW, SINCE `STD::FRONT_INSERTER` INSERTS NEW ELEMENTS AT THE BEGINNING OF THE CONTAINER, SO WE CAN PERFORM THE TASK OF `REVERSE_COPY()` JUST WITH THE HELP OF `COPY()`,
SUCH THAT WE WILL CREATE ANOTHER CONTAINER WHICH CONTAINS THE `REVERSE OF PRESENT CONTAINER`.

```TEXT
// C++ PROGRAM TO DEMONSTRATE STD::FRONT_INSERTER
#INCLUDE <IOSTREAM>
#INCLUDE <ITERATOR>
#INCLUDE <DEQUE>
#INCLUDE <ALGORITHM>
USING NAMESPACE STD;
INT MAIN()
{
    // DECLARING FIRST CONTAINER
    DEQUE<INT> V1 = { 1, 2, 3 };

    // DECLARING SECOND CONTAINER
    // FOR STORING THE REVERSE
    DEQUE<INT> V2;

    // USING STD::FRONT_INSERTER INSIDE STD::COPY
    STD::COPY(V1.BEGIN(), V1.END(), STD::FRONT_INSERTER(V2));
    // V2 NOW CONTAINS 3 2 1

    // DISPLAYING V1 AND V2
    COUT << "V1 = ";

    INT I;
    FOR (I = 0; I < 3; ++I) {
        COUT << V1[I] << " ";
    }

    COUT << "\NV2 = ";
    FOR (I = 0; I < 3; ++I) {
        COUT << V2[I] << " ";
    }

    RETURN 0;
}

OUTPUT:

V1 = 1 2 3
V2 = 3 2 1
```

## THREAD IN C++
### SLEEP FOR FUNCTION TO DELAY

```TEXT
#INCLUDE <THREAD>
#INCLUDE <CHRONO>

INT MAIN (VOID)
{
    // DELAY BETWEEN TWO SUCCESSIVE LINE PRINT
    CONST INT SLEEPTIME = 100;
    WHILE(TRUE) {
        THIS_THREAD::SLEEP_FOR(CHRONO::MILLISECONDS(SLEEPTIME));
    }
    RETURN 0;
}
```
